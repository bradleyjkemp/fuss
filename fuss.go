package fuss

import (
	"bytes"
	"encoding/binary"
	"io"
	"reflect"
	"unsafe"
)

// Fusser holds the data generated by go-fuzz
type Fusser struct {
	data []byte
}

// Seed takes the random data generated by go-fuzz and constructs
// something that can turn this into your structured data.
func Seed(data []byte) *Fusser {
	return &Fusser{data}
}

// Fuss fills an arbitrary data structure with data based on the seed
func (f *Fusser) Fuss(is ...interface{}) {
	for _, i := range is {
		v := reflect.ValueOf(i)
		if v.Kind() != reflect.Ptr && v.Kind() != reflect.Interface {
			panic("cannot fuss non-pointer value")
		}
		// passed pointer so actually fuss the inner value
		f.fussValue(v.Elem())
	}
}

func (f *Fusser) fussValue(v reflect.Value) {
	if !v.IsValid() || len(f.data) == 0 {
		// no data left so we're done
		return
	}

	switch v.Kind() {
	// Indirections
	case reflect.Ptr:
		if f.data[0] != 0 {
			f.data = f.data[1:]
			// make this pointer non-nil
			newPointer := reflect.New(v.Type().Elem())
			v.Set(newPointer)
			f.fussValue(newPointer.Elem())
		}
		// else keep it nil

	// TODO: interface :/ (hard because we have no idea what types implement what interfaces, get a hint from caller?)
	case reflect.Interface:
		f.fussInterface(v)

	// Collections
	case reflect.Struct:
		for i := 0; i < v.NumField(); i++ {
			field := v.Field(i)
			if !field.CanSet() {
				// need to use unsafe hacks to make this field set-able
				field = reflect.NewAt(field.Type(), unsafe.Pointer(field.UnsafeAddr())).Elem()
			}
			f.fussValue(field)
		}

	case reflect.Slice, reflect.Array:
		length := v.Len()
		if v.Kind() == reflect.Slice {
			// If this is a slice then choose a size
			length = int(f.data[0])
			f.data = f.data[1:]
			v.Set(reflect.MakeSlice(v.Type(), length, length))
		}
		for i := 0; i < length; i++ {
			f.fussValue(v.Index(i))
		}

	case reflect.Map:
		isNil := f.data[0] == 0 || len(f.data) == 1
		f.data = f.data[1:]
		if isNil {
			return
		}
		items := int(f.data[0])
		f.data = f.data[1:]
		v.Set(reflect.MakeMapWithSize(v.Type(), items))
		for i := 0; i < items && len(f.data) > 0; i++ {
			newKey := reflect.New(v.Type().Key()).Elem()
			f.fussValue(newKey)
			newValue := reflect.New(v.Type().Elem()).Elem()
			f.fussValue(newValue)
			v.SetMapIndex(newKey, newValue)
		}

	// Basic types
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		if len(f.data) < 8 {
			return
		}
		v.SetInt(int64(binary.BigEndian.Uint64(f.data[0:8])))
		f.data = f.data[8:]

	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		if len(f.data) < 8 {
			return
		}
		v.SetUint(binary.BigEndian.Uint64(f.data[0:8]))
		f.data = f.data[8:]

	case reflect.Bool:
		v.SetBool(f.data[0]%2 == 0)
		f.data = f.data[1:]

	case reflect.String:
		length := int(f.data[0])
		f.data = f.data[1:]
		if length > len(f.data) {
			length = len(f.data)
		}
		v.SetString(string(f.data[0:length]))
		f.data = f.data[length:]

	default:
		// type not handled yet
	}
}

var ioReader = reflect.TypeOf((*io.Reader)(nil)).Elem()

func (f *Fusser) fussInterface(v reflect.Value) {
	if len(f.data) == 0 {
		return
	}
	switch v.Type() {
	case ioReader:
		length := int(f.data[0])
		f.data = f.data[1:]
		if length > len(f.data) {
			length = len(f.data)
		}
		v.Set(reflect.ValueOf(bytes.NewReader(f.data[0:length])))
		f.data = f.data[length:]

	default:
		// don't know how to handle arbitrary interfaces yet?
		// Keep a cache of types we know about and check if they implement an interface?
	}
}
